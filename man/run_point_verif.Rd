% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run_point_verif.R
\name{run_point_verif}
\alias{run_point_verif}
\title{Run a point verification task}
\usage{
run_point_verif(
  dttm,
  fcst_model,
  param_defs,
  params = NULL,
  lead_time = seq(0, 48, 3),
  members = NULL,
  lags = "0s",
  stations = NULL,
  station_groups = NULL,
  main_fcst_model = NULL,
  ens_mean_as_det = FALSE,
  dttm_rounding = NULL,
  dttm_rounding_dirn = c("nearest", "up", "down"),
  dttm_rounding_offset = 0,
  fcst_path = getwd(),
  fcst_template = "fctable",
  fcst_format = "fctable",
  obs_path = getwd(),
  obs_template = "obstable",
  obs_format = "obstable",
  out_path = NULL,
  out_template = "point_verif",
  out_format = "rds",
  defaults = make_verif_defaults(),
  show_progress = TRUE,
  return_data = TRUE
)
}
\arguments{
\item{dttm}{A vector of date time strings to read. Can be in YYYYMMDD,
YYYYMMDDhh, YYYYMMDDhhmm, or YYYYMMDDhhmmss format. Can be numeric or
character. \code{\link[harpCore]{seq_dttm}} can be used to generate a
vector of equally spaced date-time strings.}

\item{fcst_model}{The forecast model to read - this is typically used to
construct the file name. Can be a character vector of model names.}

\item{param_defs}{The parameter definitions to be used in the verification.
These need to be set using \code{\link{make_verif_params}()}.}

\item{params}{The parameters from `param_defs` for which to do the
verification. Set to `NULL` (the default) to use all parameters in
`param_defs`.}

\item{lead_time}{The lead times to be retrieved. Can be used to construct the
file names and to set which lead times are retrieved.}

\item{members}{The members to retrieve if reading an EPS forecast. To select
the same members for all forecast models, this should be a numeric vector.
For specific members from specific models a named list with each element
having the name of the forecast model and containing a a numeric vector.
e.g. \cr \code{members = list(eps_model1 = seq(0, 3), eps_model2 = c(2,
  3))}. \cr For multi model ensembles, each element of this named list should
contain another named list with sub model name followed by the desired
members, e.g. \cr \code{members = list(eps_model1 = list(sub_model1 =
  seq(0, 3), sub_model2 = c(2, 3)))}}

\item{lags}{The lags that were used when the forecast was run. If, for
example, the FCTABLE files are constructed from lagged model runs the lags
must be given here to ensure that the correct file names are generated. If,
however, you simply want to add lagged members to a forecast, you should do
that using \link[harpPoint]{lag_forecast}.}

\item{stations}{The stations to retrieve forecasts for. This should be a
vector of station ID numbers. Set to NULL to retrieve all stations.}

\item{station_groups}{A data frame defining groups each station belongs to.
Should have column names "SID" for station ID and "station_group" for the
group name.}

\item{main_fcst_model}{The `fcst_model` to treat as the main model. If not
NULL, the stations will first be selected from this model and only these
stations will be read from other `fcst_model`s. This will speed up the
reading of data. In general the model with the smallest domain should be
chosen as `main_fcst_model`. Will be ignored if `stations` is not NULL.}

\item{ens_mean_as_det}{Logical. For ensembles, should the ensemble mean be
verified as a deterministic forecast.}

\item{dttm_rounding}{The multiple to which to round valid date-times. This
should be a number followed "s", "m", "h", or "d" for seconds, minutes,
hours and days. This is useful for aggregating data over time periods when
stratifying verification by valid_dttm.}

\item{dttm_rounding_dirn}{The direction in which to round date-times. Can be
"nearest", "up" or "down". For "nearest", the rounding is centred on
`dttm_rounding`. Where there is an even number of date-times to be
aggregated, the averaging window favours date-times before the rounding
time. For example, if rounding date-times to "6h", the aggregation for 06
UTC will take in 03, 04, 05, 06, 07 and 08 UTC, and the aggregation for 12
UTC will take in 09, 10, 11, 12, 13 and 14 UTC etc. For "up" the rounding
is for a window for all times up to and including `dttm_rounding` and for
"down" the rounding is for a window starting at `dttm_rounding`.}

\item{dttm_rounding_offset}{The offset to be applied to `dttm_rounding`. This
should be a number followed "s", "m", "h", or "d" for seconds, minutes,
hours and days. This is used to centre the rounding. For example, if
`dttm_rounding` = "1d", the rounding will be centred on 00 UTC. If you want
it to be centred on 12 UTC, you would supply an offset of "12h". Note that
the offset is applied backwards in time, so if you want to centre on 06
UTC, for example, the offset should be "18h".}

\item{fcst_path}{The path for the forecast files.}

\item{fcst_template}{The template for the forecast files.}

\item{fcst_format}{The format of the forecast files. Currently this is
limited to "fctable", but may be extended in the future to allow for other
file formats.}

\item{obs_path}{The path for the observations files.}

\item{obs_template}{The template for the observations files.}

\item{obs_format}{The format of the observations files. Currently this is
limited to "obstable", but may be extended in the future to allow for other
file formats.}

\item{out_path}{The path to which to write output verification files.}

\item{out_template}{The template for output verification files.}

\item{out_format}{The format for output verification files. This is currently
limited to the native R format "rds", but will be extended in the future to
include SQLite and JSON.}

\item{defaults}{The defaults for the verification. Set using
\code{\link{make_verif_defaults}()}. These defaults currently only cover
verification groups and the number of standard deviations to use in the
observation error checking.}

\item{return_data}{Logical. Whether to return the verification results to the
global environment. Automatically set to TRUE if `out_path` is `NULL`.}
}
\value{
If `return_data = TRUE`, a list of data frames with the verification
  scores. Otherwise there is only the side effect of writing the verification
  scores to files.
}
\description{
`run_point_verif()` runs a point verification task for one or more
parameters. It reads forecasts and observations from files and computes
verification scores. Deterministic or ensemble scores are computed depending
on the data.
}
\details{
Currently it is only possible to read point data from harp formatted SQLite
files. These can be created using \code{\link[harpIO]{read_forecast}()} and
\code{\link[harpIO]{read_obs}()} for forecast and observations data
respectively.

Many of the verification options are set at the parameter level. This means
that parameters must be passed to `run_point_verif()` in a specific format.
Parameters with this format can be created using
\code{\link{make_verif_param}()}. For options that are common across all
parameters, such as verification groups, the `defaults` argument should be
used passing data created with \code{\link{make_verif_defaults}}.
}
